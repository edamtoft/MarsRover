<html>
<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      color: #222;
    }
    mars-plateau {
      display: block;
      background-color: #FFA07A;
      position: relative;
    }
    mars-rover {
      display: block;
      background-color: #666;
      height: 50px;
      width: 50px;
      position: absolute;
      bottom: 0;
      left: 0;
      text-align: center;
      line-height: 50px;
    }
    mars-rover[data-crashed=true] {
      background-color: red;
    }
    mars-rover::after {
      content: 'NASA';
    }
  </style>
</head>
<body>
  <h1>Mars Rovers</h1>
  <mars-plateau 
    id="plateau"
    data-scale="50"
    data-x-size="5"
    data-y-size="5"
    data-animation-duration="500">
  </mars-plateau>
  <pre>Commands:
L: turn left
R: turn right
M: move forward
N: [Keyboard only] Add new rover at 0 0 N
  </pre>
  <form id="commands-form">
  <textarea cols="50" rows="5" id="commands-input">5 5
1 2 N
LMLMLMLMM
3 3 E
MMRMMRMRRM</textarea>
  <br/>
  <button type="submit">Go</button>
  </form>
  <script>

  class Coordinate
  {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      Object.freeze(this); //force read-only
    }

    at(degrees,distance) {
      const rad = (Math.PI / 180.0) * (degrees % 360);
      const dx = distance * Math.sin(rad);
      const dy = distance * Math.cos(rad);
      const x = (this.x + dx).toFixed(4);
      const y = (this.y + dy).toFixed(4);
      return new Coordinate(x,y);
    }

    toString() { return `${this.x}, ${this.y}`; }
  }

  document.registerElement("mars-plateau", class extends HTMLElement
  {  
    constructor() {
      super();
      this._selectedRover = null;
    }

    createdCallback() {
      this.attributeChangedCallback(); // make sure attributes are initialized
      document.addEventListener("keydown", e => this._keyPressed(e.keyCode));
    }

    attributeChangedCallback() {
      this.style.width = `${(this.size.x + 1) * this.scale}px`;
      this.style.height = `${(this.size.y + 1) * this.scale}px`;
    }

    _keyPressed(keyCode) {
      if (keyCode == 78) { this.createRover(0,0,"N"); return; } //N
      const rovers = this.rovers;
      const activeRover = rovers[rovers.length-1];
      if (!activeRover) return;
      const action = (() => {
        switch (keyCode) {
          case 76: return r => r.turnLeft(); //L
          case 77: return r => r.move(); //R
          case 82: return r => r.turnRight(); //M
          default: return null;
        }
      })();
      if (action) action(activeRover);
    }

    get rovers() { return this.getElementsByTagName("mars-rover"); }

    get scale() { return Number(this.dataset.scale) || 50; }

    get size() { 
      return new Coordinate(
        Number(this.dataset.xSize) || Number.MAX_VALUE, 
        Number(this.dataset.ySize) || Number.MAX_VALUE); 
    }

    set size(size) { 
      this.dataset.xSize = size.x;
      this.dataset.ySize = size.y;
    }

    createRover(x,y,heading) {
      const rover = document.createElement("mars-rover");
      rover.dataset.x = x;
      rover.dataset.y = y;
      rover.dataset.heading = (heading => {
        switch (heading.toUpperCase()) {
          case "N": return 0;
          case "E": return 90;
          case "S": return 180;
          case "W": return 270;
          default: throw new Error("Unrecognized direction. Use [NESW]");
        }
      })(heading||"");
      this.appendChild(rover);
      return rover;
    }

    parseRover(positionString) {
      const regex = /(\d+) (\d+) ([NESW])/i;
      if (!regex.test(positionString)) throw new Error(`Unable to read rover positon ${positionString}. Format is "X Y [NESW]".`)
      const [,x,y,heading] = regex.exec(positionString);
      return this.createRover(x,y,heading);
    }

    execute(string) {
      const lines = string.split(/\n/g);
      const plateauSizeRegex = /(\d+) (\d+)/;
      const [plateauSize, ...roverCommands] = lines;
      const [,x,y] = plateauSizeRegex.exec(plateauSize);
      this.size = new Coordinate(x,y);
      const actions = [];
      for (var i = 0; i < roverCommands.length; i+=2) {
        const position = roverCommands[i];
        const commands = roverCommands[i+1];
        if (!position || !commands) continue;
        actions.push(
          this
            .parseRover(position)
            .processCommands(commands)
            .catch(err => console.error(err)));
      }
      return Promise.all(actions);
    }

    clear() {
      while(this.firstChild) {
        this.removeChild(this.firstChild);
      }
    }

    getRoverPositions() {
      const parts = [];
      for (let rover of this.rovers) {
        parts.push(rover.toString());
      }
      return parts;
    }
  });

  document.registerElement("mars-rover", class extends HTMLElement 
  {
    constructor() {
      super();
      this._isMoving = false;
    }

    //
    // Properties
    //

    get heading() { return Number(this.dataset.heading||0); }
    set heading(degrees) { this.dataset.heading=degrees; }

    get position() { 
      return new Coordinate(
        Number(this.dataset.x||0),
        Number(this.dataset.y||0)); 
    }
    set position(coordinate) {
      const {x,y} = coordinate;
      this.dataset.x = x;
      this.dataset.y = y;
    }

    get crashed() { return this.dataset.crashed; }

    get plateau() { return this.parentElement; }

    attributeChangedCallback() {
      const { x, y, heading } = this.dataset;
      const { size, scale } = this.plateau;
      if (!this.crashed && (x > size.x || y > size.y )) {
        this.dataset.crashed = true;
      }
      this.style.transform = `rotate(${heading||0}deg)`;
      this.style.bottom = `${(y||0)*scale}px`;
      this.style.left = `${(x||0)*scale}px`;
    }

    toString() { 
      const {x,y} = this.position;
      let cardinalDirection = (heading => {
        switch (Math.abs(heading % 360)) {
          case 0: return "N";
          case 90: return "E";
          case 180: return "S";
          case 270: return "W";
          default: return heading;
        }
      })(this.heading||0);
      return this.crashed ? 
        `Crashed at ${x} ${y} ${cardinalDirection}` :
        `${x} ${y} ${cardinalDirection}`;
    }

    //
    // Movements
    //

    turnLeft() { return this.turn(-90); }
    turnRight() { return this.turn(90); }

    move() {
      if (this._isMoving) return;
      this._isMoving = true;
      if (this.crashed) throw new Error("Rover is crashed. Cannot move");
      console.debug(`Moving forward.`);
      const initialPosition = this.position;
      const heading = this.heading;
      return this._animate(progress => this.position = initialPosition.at(heading, progress)).then(() => this._isMoving = false);
    }

    turn(degrees)
    {
      if (this._isMoving) return;
      this._isMoving = true;
      if (this.crashed) throw new Error("Rover is crashed. Cannot move");
      console.debug(`Turning ${degrees}deg.`);
      const initialHeading = this.heading;
      return this._animate(progress => this.heading = initialHeading + (degrees*progress)).then(() => this._isMoving = false);
    }

    //
    // animate
    //

    _animate(onNext) {
      const duration = Number(this.plateau.dataset.animationDuration) || 500;
      return new Promise((resolve,reject) => {
        let start = null;
        const next = time => {
          if (!start) start = time;
          const progress = (time - start) / duration;
          if (progress < 1.0) { 
            onNext(progress);
            requestAnimationFrame(next);
          } else {
            onNext(1.0);
            resolve();
          };
        }
        requestAnimationFrame(next);
      });
    }

    //
    // Commands
    //

    processCommands(commands) {
      const [first, ...rest] = commands;
      if (!first) return Promise.resolve(); // nothing to do
      return this.processCommand(first)
        .then(() => rest.length > 0 ? 
          this.processCommands(rest) : 
          Promise.resolve());
    }

    processCommand(command) {
      switch ((command||"").toUpperCase()) {
        case 'L':
          return this.turnLeft();
        case 'R':
          return this.turnRight();
        case 'M':
          return this.move();
        default:
          return Promise.resolve(); // NoOp
      }
    }
  });


  // Wire up form

  const plateau = document.getElementById("plateau");
  const commandsForm = document.getElementById("commands-form");
  const commandsInput = document.getElementById("commands-input");
  commandsForm.addEventListener("submit", e => {
    e.preventDefault();
    plateau.clear();
    plateau.execute(commandsInput.value).then(() => alert(plateau.getRoverPositions().join("\n")));
  });
  
  </script>
</body>
</html>